/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef TOOLS_FTRACE_PROTO_GEN_FTRACE_DESCRIPTOR_GEN_H_
#define TOOLS_FTRACE_PROTO_GEN_FTRACE_DESCRIPTOR_GEN_H_

#include <google/protobuf/descriptor.h>
#include <google/protobuf/descriptor.pb.h>

#include "perfetto/base/logging.h"
#include "tools/ftrace_proto_gen/ftrace_proto_gen.h"

namespace perfetto {

static void GenerateFtraceDescriptors(
    const google::protobuf::DescriptorPool& descriptor_pool,
    std::ostream* fout) {
  const google::protobuf::Descriptor* ftrace_event =
      descriptor_pool.FindMessageTypeByName("perfetto.protos.FtraceEvent");
  const google::protobuf::OneofDescriptor* one_of_event =
      ftrace_event->FindOneofByName("event");
  int max_id = one_of_event->field(one_of_event->field_count() - 1)->number();

  *fout << "// Autogenerated by:\n";
  *fout << std::string("// ") + __FILE__ + "\n";
  *fout << "// Do not edit.\n";
  *fout << R"(
  #ifndef SRC_TRACE_PROCESSOR_FTRACE_DESCRIPTORS_H_
  #define SRC_TRACE_PROCESSOR_FTRACE_DESCRIPTORS_H_

  #include <array>
  #include "perfetto/protozero/proto_utils.h"

  namespace perfetto {

  using protozero::proto_utils::ProtoFieldType;

  struct FieldDescriptor {
    const char* name;
    ProtoFieldType type;
  };

  struct MessageDescriptor {
    const char* name;
    FieldDescriptor fields[32];
  };

  static std::array<MessageDescriptor,
  )";
  *fout << std::to_string(max_id + 1) + "> descriptors{{";

  int proto_id = 0;
  for (int i = 0; i < one_of_event->field_count(); i++) {
    const google::protobuf::FieldDescriptor* event = one_of_event->field(i);
    const google::protobuf::Descriptor* event_descriptor =
        event->message_type();
    // For proto ids that do not have an event output an empty descriptor.
    while (proto_id != event->number()) {
      *fout << "{},";
      ++proto_id;
    }
    // Output empty descriptor for generic since it contains a nested message.
    // We know how to parse generic events so the descriptor is unecessary
    // anyway.
    if (event->name() == "generic") {
      *fout << "{},";
      ++proto_id;
      continue;
    }
    *fout << "{\"" + event->name() + "\", {";
    int field_id = 0;
    for (int j = 0; j < event_descriptor->field_count(); j++) {
      const google::protobuf::FieldDescriptor* field =
          event_descriptor->field(j);
      // For field ids with no field outpit an empty field.
      while (field_id != field->number()) {
        *fout << "{},";
        ++field_id;
      }
      ProtoType type = ProtoType::FromDescriptor(field->type());
      *fout << "{\"" + field->name() + "\", ProtoFieldType::kProto" +
                   ToCamelCase(type.ToString()) + "},";
      ++field_id;
    }
    *fout << "},\n},";
    ++proto_id;
  }
  *fout << "}};\n";

  *fout << "} // namespace perfetto\n";
  *fout << "#endif  // SRC_TRACE_PROCESSOR_FTRACE_DESCRIPTORS_H_\n";
}
}  // namespace perfetto
#endif  // TOOLS_FTRACE_PROTO_GEN_FTRACE_DESCRIPTOR_GEN_H_
