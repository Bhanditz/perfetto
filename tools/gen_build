#!/usr/bin/env python
# Copyright (C) 2018 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This tool translates a collection of BUILD.gn files into a mostly equivalent
# BUILD file for the Bazel build system. The input to the tool is a
# JSON description of the GN build definition generated with the following
# command:
#
#   gn desc out --format=json --all-toolchains "//*" > desc.json
#
# The tool is then given a list of GN labels for which to generate Bazel
# build rules.

import argparse
import errno
import json
import os
import re
import shutil
import subprocess
import sys
import textwrap

# Copyright header for generated code.
header = """# Copyright (C) 2018 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# This file is automatically generated by {}. Do not edit.
""".format(__file__)

# Arguments for the GN output directory.
gn_args = 'target_os="macosx" is_debug=false'

# Default targets to translate to the blueprint file.
default_targets = [
    '//src/trace_processor:trace_processor_lib',
]

def enable_gmock(module):
    module.static_libs.append('libgmock')


def enable_gtest_prod(module):
    return
    module.static_libs.append('libgtest_prod')


def enable_gtest(module):
    assert module.type == 'cc_test'


def enable_protobuf_full(module):
    return
    module.shared_libs.append('libprotobuf-cpp-full')


def enable_protobuf_lite(module):
    return
    module.shared_libs.append('libprotobuf-cpp-lite')


def enable_protoc_lib(module):
    module.shared_libs.append('libprotoc')


def enable_libunwind(module):
    # libunwind is disabled on Darwin so we cannot depend on it.
    pass


def enable_sqlite(module):
    pass


def enable_default_deps(module):
    # The default settings for Bazel substitute for the default deps.
    pass


def enable_standalone_toolchain(module):
    # The default settings for Bazel substitute for the toolchain.
    pass


# Android equivalents for third-party libraries that the upstream project
# depends on.
builtin_deps = {
    '//buildtools:gmock': enable_gmock,
    '//buildtools:gtest': enable_gtest,
    '//gn:gtest_prod_config': enable_gtest_prod,
    '//buildtools:gtest_main': enable_gtest,
    '//buildtools:libunwind': enable_libunwind,
    '//buildtools:protobuf_full': enable_protobuf_full,
    '//buildtools:protobuf_lite': enable_protobuf_lite,
    '//buildtools:protoc_lib': enable_protoc_lib,
    '//buildtools:sqlite': enable_sqlite,
    '//gn:default_deps': enable_default_deps,
    '//gn/standalone/toolchain': enable_standalone_toolchain,
}

# ----------------------------------------------------------------------------
# End of configuration.
# ----------------------------------------------------------------------------


def repo_root():
  """Returns an absolute path to the repository root."""

  return os.path.join(
      os.path.realpath(os.path.dirname(__file__)), os.path.pardir)


def create_build_description():
  """Creates the JSON build description by running GN."""

  out = os.path.join(repo_root(), 'out', 'tmp.gen_android_bp')
  try:
    try:
      os.makedirs(out)
    except OSError as e:
      if e.errno != errno.EEXIST:
        raise
    subprocess.check_output(
      ['gn', 'gen', out, '--args=%s' % gn_args], cwd=repo_root())
    desc = subprocess.check_output(
      ['gn', 'desc', out, '--format=json', '--all-toolchains', '//*'],
      cwd=repo_root())
    return json.loads(desc)
  finally:
    shutil.rmtree(out)


def label_to_path(label):
  """Turn a GN output label (e.g., //some_dir/file.cc) into a path."""
  assert label.startswith('//')
  return label[2:]


def label_to_target_name(label):
  """Turn a GN label (e.g., //:perfetto_tests) into a target name."""
  name = re.sub(r'^//:?', '', label)
  name = re.sub(r'[^a-zA-Z0-9_]', '_', name)
  return name


def label_without_toolchain(label):
  """Strips the toolchain from a GN label.

  Return a GN label (e.g //buildtools:protobuf(//gn/standalone/toolchain:
  gcc_like_host) without the parenthesised toolchain part.
  """
  return label.split('(')[0]

def is_generated_by_action(desc, label):
    """Checks if a label is generated by an action.

    Returns True if a GN output label |label| is an output for any action,
    i.e., the file is generated dynamically.
    """
    for target in desc.itervalues():
        if target['type'] == 'action' and label in target['outputs']:
            return True
    return False


def resolve_dependencies(desc, target_name):
  """Return the transitive set of dependent-on targets for a GN target.

  Args:
      desc: JSON GN description.
      target_name: Name of target

  Returns:
      A set of transitive dependencies in the form of GN targets.
  """

  if label_without_toolchain(target_name) in builtin_deps:
      return set()
  target = desc[target_name]
  resolved_deps = set()
  for dep in target.get('deps', []):
    resolved_deps.add(dep)
    # Ignore the transitive dependencies of actions because they are
    # explicitly converted to genrules.
    if desc[dep]['type'] == 'action':
      continue
    # Dependencies on shared libraries shouldn't propagate any transitive
    # dependencies but only depend on the shared library target
    if desc[dep]['type'] == 'shared_library':
      continue
    resolved_deps.update(resolve_dependencies(desc, dep))
  return resolved_deps


class Writer(object):
  def __init__(self, output, width=79):
    self.output = output
    self.width = width

  def comment(self, text):
    for line in textwrap.wrap(text,
        self.width - 2,
        break_long_words=False,
        break_on_hyphens=False):
      self.output.write('# {}\n'.format(line))

  def newline(self):
    self.output.write('\n')

  def _line(self, s, indent=0):
    self.output.write('    ' * indent + s + '\n')

  def variable(self, key, value, sort=True):
    if value is None:
      return
    if isinstance(value, list):
      if len(value) == 0:
        return
      self._line('{} = ['.format(key), indent=1)
      for v in sorted(value) if sort else value:
        self._line('"{}",'.format(v), indent=2)
      self._line('],', indent=1)
    else:
      self._line('{} = "{}",'.format(key, value), indent=1)

  def rule(self, type, name, srcs=None, deps=None):
    self._line('{}('.format(type))
    self.variable('name', name)
    self.variable('srcs', srcs)
    self.variable('deps', deps)
    self.variable('copts', [
        '-I{}'.format('include'),
        '-I{}'.format('.'),
    ])
    self.variable('linkopts', [
    ])

    if type == 'proto_library':
      pass

    self._line(')')

  def header(self):
    self.output.write(header)


class Target(object):
  """In-memory representation of a BUILD target."""

  def __init__(self, type, name):
    assert type in ('cc_binary', 'cc_library', 'proto_library', 'filegroup',)
    self.type = type
    self.name = name
    self.srcs = []
    self.deps = []
    self.gn_name = None

  def write(self, writer):
    if self.gn_name:
      writer.comment('GN target: {}'.format(self.gn_name))
    writer.rule(self.type, self.name, srcs=self.srcs, deps=self.deps)


class Build(object):
  """In-memory representation of a BUILD file."""

  def __init__(self):
    self.targets = {}

  def add_target(self, target):
    self.targets[target.name] = target

  def write(self, writer):
    writer.header()
    writer.newline()
    for target in sorted(self.targets.itervalues(), key=lambda m: m.name):
      target.write(writer)


def create_build_for_targets(desc, targets):
  """Generate a BUILD for a list of GN targets."""
  build = Build()
  proto_build = Build()

  for target in targets:
    create_target(build, proto_build, desc, target)

  return (build, proto_build)


def apply_module_dependency(build, proto_build, desc, target, dep_name):
    """
    Args:
        blueprint: Blueprint instance which is being generated.
        desc: JSON GN description.
        module: Module to which dependencies should be added.
        dep_name: GN target of the dependency.
    """
    # If the dependency refers to a library which we can replace with an Android
    # equivalent, stop recursing and patch the dependency in.
    if label_without_toolchain(dep_name) in builtin_deps:
        builtin_deps[label_without_toolchain(dep_name)](target)
        return

    # Similarly some shared libraries are directly mapped to Android
    # equivalents.
    dep_desc = desc[dep_name]
    if dep_desc['type'] == 'source_set':
      # Any source set which has a source generated by an action doesn't need
      # to be depended on as we will depend on the action directly.
      for src in dep_desc['sources']:
        if is_generated_by_action(desc, src):
            return
      target.srcs.append(label_to_target_name(dep_name))
      create_target(build, proto_build, desc, dep_name)
    elif dep_desc['type'] == 'action':
      target.srcs.append("protos:" + label_to_target_name(dep_name))
      create_target(build, proto_build, desc, dep_name)
    else:
      raise Exception('Unknown target type: %s' % dep_desc['type'])

def create_target(build, proto_build, desc, target_name):
  """Generate module(s) for a given GN target.

  Given a GN target name, generate one or more corresponding modules into a
  blueprint.

  Args:
      blueprint: Blueprint instance which is being generated.
      desc: JSON GN description.
      target_name: GN target for module generation.
  """
  target_desc = desc[target_name]
  if target_desc['type'] == 'action':
    args = target_desc['args']
    if not args[0].endswith('/protoc'):
        raise Error('Unsupported action in target %s: %s' % (target_name,
                                                             target['args']))
    target = Target('proto_library', label_to_target_name(target_name))
    target.gn_name = target_name
    target.srcs.extend(label_to_path(src) for src in target_desc.get('sources', []))
    proto_build.add_target(target)
    return

  if target_desc['type'] == 'executable':
    target = Target('cc_binary', label_to_target_name(target_name))
  elif target_desc['type'] == 'static_library':
    target = Target('cc_library', label_to_target_name(target_name))
  elif target_desc['type'] == 'source_set':
    target = Target('filegroup', label_to_target_name(target_name))
  else:
    raise Exception('Unknown target type: %s' % target_desc['type'])

  target.gn_name = target_name
  target.srcs.extend(label_to_path(src) for src in target_desc.get('sources', []))

  for dep_name in resolve_dependencies(desc, target_name):
    apply_module_dependency(build, proto_build, desc, target, dep_name)

  build.add_target(target)


def main():
  parser = argparse.ArgumentParser(
      description='Generate BUILD from a GN description.')
  parser.add_argument(
      '--desc',
      help=
      'GN description (e.g., gn desc out --format=json --all-toolchains "//*"'
  )
  parser.add_argument(
      '--output',
      help='Blueprint file to create',
      default=os.path.join(repo_root(), 'BUILD'),
  )
  parser.add_argument(
      '--output-proto',
      help='Blueprint file to create',
      default=os.path.join(repo_root(), 'protos', 'BUILD'),
  )
  parser.add_argument(
      'targets',
      nargs=argparse.REMAINDER,
      help='Targets to include in the blueprint (e.g., "//:perfetto_tests")')
  args = parser.parse_args()

  if args.desc:
    with open(args.desc) as f:
      desc = json.load(f)
  else:
    desc = create_build_description()

  (build, proto_build) = create_build_for_targets(desc, args.targets or default_targets)
  with open(args.output, 'w') as f:
    build.write(Writer(f))

  with open(args.output_proto, 'w') as f:
    proto_build.write(Writer(f))

if __name__ == '__main__':
  sys.exit(main())
