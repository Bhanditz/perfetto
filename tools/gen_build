#!/usr/bin/env python
# Copyright (C) 2018 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This tool translates a collection of BUILD.gn files into a mostly equivalent
# BUILD file for the Bazel build system. The input to the tool is a
# JSON description of the GN build definition generated with the following
# command:
#
#   gn desc out --format=json --all-toolchains "//*" > desc.json
#
# The tool is then given a list of GN labels for which to generate Bazel
# build rules.

import argparse
import errno
import json
import os
import re
import shutil
import subprocess
import sys
import textwrap

# Copyright header for generated code.
header = """# Copyright (C) 2018 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# This file is automatically generated by {}. Do not edit.
""".format(__file__)

# Arguments for the GN output directory.
gn_args = 'target_os="linux" is_debug=false'

# Default targets to translate to the blueprint file.
default_targets = [
    '//tools/skippy:skippy',
]

# ----------------------------------------------------------------------------
# End of configuration.
# ----------------------------------------------------------------------------


def repo_root():
  """Returns an absolute path to the repository root."""

  return os.path.join(
      os.path.realpath(os.path.dirname(__file__)), os.path.pardir)


def create_build_description():
  """Creates the JSON build description by running GN."""

  out = os.path.join(repo_root(), 'out', 'tmp.gen_android_bp')
  try:
    try:
      os.makedirs(out)
    except OSError as e:
      if e.errno != errno.EEXIST:
        raise
    subprocess.check_output(
      ['gn', 'gen', out, '--args=%s' % gn_args], cwd=repo_root())
    desc = subprocess.check_output(
      ['gn', 'desc', out, '--format=json', '--all-toolchains', '//*'],
      cwd=repo_root())
    return json.loads(desc)
  finally:
    shutil.rmtree(out)


def label_to_path(label):
  """Turn a GN output label (e.g., //some_dir/file.cc) into a path."""
  assert label.startswith('//')
  return label[2:]


def label_to_target_name(label):
  """Turn a GN label (e.g., //:perfetto_tests) into a target name."""
  name = re.sub(r'^//:?', '', label)
  name = re.sub(r'[^a-zA-Z0-9_]', '_', name)
  return name


def label_without_toolchain(label):
  """Strips the toolchain from a GN label.

  Return a GN label (e.g //buildtools:protobuf(//gn/standalone/toolchain:
  gcc_like_host) without the parenthesised toolchain part.
  """
  return label.split('(')[0]


def resolve_dependencies(desc, target_name):
  """Return the transitive set of dependent-on targets for a GN target.

  Args:
      desc: JSON GN description.
      target_name: Name of target

  Returns:
      A set of transitive dependencies in the form of GN targets.
  """

  target = desc[target_name]
  resolved_deps = set()
  for dep in target.get('deps', []):
    resolved_deps.add(dep)
    # Ignore the transitive dependencies of actions because they are
    # explicitly converted to genrules.
    if desc[dep]['type'] == 'action':
      continue
    # Dependencies on shared libraries shouldn't propagate any transitive
    # dependencies but only depend on the shared library target
    if desc[dep]['type'] == 'shared_library':
      continue
    resolved_deps.update(resolve_dependencies(desc, dep))
  return resolved_deps


class Writer(object):
  def __init__(self, output, width=79):
    self.output = output
    self.width = width

  def comment(self, text):
    for line in textwrap.wrap(text,
        self.width - 2,
        break_long_words=False,
        break_on_hyphens=False):
      self.output.write('# {}\n'.format(line))

  def newline(self):
    self.output.write('\n')

  def _line(self, s, indent=0):
    self.output.write('    ' * indent + s + '\n')

  def variable(self, key, value):
    if value is None:
      return
    if isinstance(value, list):
      self._line('{} = ['.format(key), indent=1)
      for v in value:
        self._line('"{}",'.format(v), indent=2)
      self._line('],', indent=1)
    else:
      self._line('{} = "{}",'.format(key, value), indent=1)

  def rule(self, type, name, srcs=None):
    if srcs:
      srcs.sort()
    self._line('{}('.format(type))
    self.variable('name', name)
    self.variable('srcs', srcs)
    self.variable('copts', [
        '-I{}'.format('include'),
    ])
    self.variable('linkopts', [
       '-l{}'.format('pthread'),
       '-l{}'.format('rt'),
    ])
    self._line(')')

  def header(self):
    self.output.write(header)


class Target(object):
  """In-memory representation of a BUILD target."""

  def __init__(self, type, name):
    assert type in ('cc_binary',)
    self.type = type
    self.name = name
    self.srcs = []
    self.gn_name = None

  def write(self, writer):
    if self.gn_name:
      writer.comment('GN target: {}'.format(self.gn_name))
    writer.rule(self.type, self.name, srcs=self.srcs)


class Build(object):
  """In-memory representation of a BUILD file."""

  def __init__(self):
    self.targets = []

  def add_target(self, target):
    self.targets.append(target)

  def write(self, writer):
    writer.header()
    writer.newline()
    for target in self.targets:
      target.write(writer)


def create_build_for_targets(desc, targets):
  """Generate a BUILD for a list of GN targets."""
  build = Build()

  for target in targets:
    create_target(build, desc, target)

  return build


def create_target(build, desc, target_name):
  """Generate module(s) for a given GN target.

  Given a GN target name, generate one or more corresponding modules into a
  blueprint.

  Args:
      blueprint: Blueprint instance which is being generated.
      desc: JSON GN description.
      target_name: GN target for module generation.
  """
  target_desc = desc[target_name]
  if target_desc['type'] == 'executable':
    target = Target('cc_binary', label_to_target_name(target_name))
    target.gn_name = target_name
    target.srcs.extend(label_to_path(src) for src in target_desc['sources'])
    for dep_name in resolve_dependencies(desc, target_name):
      print(dep_name)
      if 'src' not in dep_name and 'include' not in dep_name:
        continue
      dep_desc = desc[dep_name]
      target.srcs.extend(label_to_path(src) for src in dep_desc['sources'])
  else:
    raise Error('Unknown target type: %s' % target['type'])

  build.add_target(target)


def main():
  parser = argparse.ArgumentParser(
      description='Generate BUILD from a GN description.')
  parser.add_argument(
      '--desc',
      help=
      'GN description (e.g., gn desc out --format=json --all-toolchains "//*"'
  )
  parser.add_argument(
      '--output',
      help='Blueprint file to create',
      default=os.path.join(repo_root(), 'BUILD'),
  )
  parser.add_argument(
      'targets',
      nargs=argparse.REMAINDER,
      help='Targets to include in the blueprint (e.g., "//:perfetto_tests")')
  args = parser.parse_args()

  if args.desc:
    with open(args.desc) as f:
      desc = json.load(f)
  else:
    desc = create_build_description()

  build = create_build_for_targets(desc, args.targets or default_targets)
  with open(args.output, 'w') as f:
    build.write(Writer(f))

if __name__ == '__main__':
  sys.exit(main())
