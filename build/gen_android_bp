#!/usr/bin/env python
# Copyright (C) 2017 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import json
import os
import re
import sys

#    "//base:base_unittests": {
#        "all_dependent_configs": [
#            "//buildtools:googletest_config"
#        ],
#        "allow_circular_includes_from": [],
#        "asmflags": [
#        ],
#        "cflags": [
#        ],
#        "cflags_cc": [
#        ],
#        "check_includes": true,
#        "configs": [
#          // Not defined anywhere? Map some known ones like googletest_config.
#        ],
#        "defines": [
#          // Whitelist these.
#        ],
#        "deps": [
#          // Walk these recursively.
#        ],
#        "include_dirs": [
#          // Allow repo-relative paths.
#        ],
#        "ldflags": [
#          // Shouldn't need any of these.
#        ],
#        "lib_dirs": [
#          // Ditto.
#        ],
#        "libs": [
#          // Whitelist?
#        ],
#        "outputs": [
#          // Map to cc_binary / cc_binary_host
#        ],
#        "public": "*",
#        "sources": [
#          // Drop headers.
#        ],
#        "testonly": true,  // Ignore.
#        // Use to determine if this is host or target.
#        "toolchain": "//build/toolchain:gcc_like",
#        "type": "executable",  // cc_binary / cc_binary_host
#        "visibility": [
#          // Ignore.
#        ]
#    },
#

class Error(Exception):
    pass


class Module(object):
    def __init__(self, type, name):
        self.type = type
        self.name = name
        self.srcs = []
        self.comment = None
        self.shared_libs = []
        self.static_libs = []

    def to_string(self, output):
        if self.comment:
            output.append('// %s' % self.comment)
        output.append('%s {' % self.type)
        output.append('  name: "%s",' % self.name)
        self._output_list(output, 'srcs', self.srcs)
        self._output_list(output, 'shared_libs', self.shared_libs)
        self._output_list(output, 'static_libs', self.static_libs)
        output.append('}')
        output.append('')

    def _output_list(self, output, name, list):
        if not list:
            return
        output.append('  %s: [' % name)
        for item in sorted(list):
            output.append('    "%s",' % item)
        output.append('  ],')


class Blueprint(object):
    def __init__(self):
        self.modules = []

    def to_string(self, output):
        for m in self.modules:
            m.to_string(output)


def label_to_path(label):
    assert label.startswith('//')
    return label[2:]


def label_to_module_name(label):
    target = label.split(':')[1]
    return re.sub(r'[^a-zA-Z0-9_]', '_', target)


def is_supported_source_file(name):
    return os.path.splitext(name)[1] in ['.c', '.cc', '.proto']


def enable_gmock(module):
    module.static_libs.append('libgmock')


def enable_gtest(module):
    assert module.type == 'cc_test'


def enable_protobuf_full(module):
    module.shared_libs.append('libprotobuf-cpp-full')


def enable_protobuf_lite(module):
    module.shared_libs.append('libprotobuf-cpp-lite')


builtin_deps = {
    '//buildtools:gmock': enable_gmock,
    '//buildtools:gtest': enable_gtest,
    '//buildtools:gtest_main': enable_gtest,
    # TODO(skyostil): Remove after this isn't used anymore.
    '//buildtools:protobuf_full': enable_protobuf_full,
    '//buildtools:protobuf_lite': enable_protobuf_lite,
}

def apply_module_dependency(blueprint, desc, module, dep_name):
    if dep_name in builtin_deps:
        return builtin_deps[dep_name](module)
    target = desc[dep_name]
    # HACK
    if 'host' in target['toolchain']:
        return
    if target['type'] == 'action':
        create_modules_from_target(blueprint, desc, dep_name)
        module.srcs.append(':' + label_to_module_name(dep_name))
    elif target['type'] in ['group', 'source_set'] and 'sources' in target:
        module.srcs.extend(label_to_path(src) for src in target['sources'] if is_supported_source_file(src))


def create_modules_from_target(blueprint, desc, target_name):
    target = desc[target_name]
    if target['type'] == 'executable':
        if 'host' in target['toolchain']:
            module_type = 'cc_binary_host'
        elif target.get('testonly', False):
            module_type = 'cc_test'
        else:
            module_type = 'cc_binary'
    #elif target['type'] in ['group', 'source_set']:
    #    module_type = 'filegroup'
    elif target['type'] == 'action':
        module_type = 'cc_genrule'
    else:
        raise Error('Unknown target type: %s' % target['type'])
        #return None
    module = Module(module_type, label_to_module_name(target_name))
    module.comment = 'GN target: %s' % target_name

    for dep in resolve_dependencies(desc, target_name):
        apply_module_dependency(blueprint, desc, module, dep)

    #if 'sources' in target:
    #    module.srcs.extend(label_to_path(src) for src in target['sources'] if is_supported_source_file(src))
    #if 'deps' in target:
    #    module.srcs.extend(':' + label_to_module_name(dep) for dep in target['deps'])
    blueprint.modules.append(module)


def resolve_dependencies(desc, target_name):
    if target_name in builtin_deps:
        return set()
    target = desc[target_name]
    resolved_deps = set()
    for dep in target.get('deps', []):
        resolved_deps.add(dep)
        resolved_deps.update(resolve_dependencies(desc, dep))
    return resolved_deps


def create_blueprint_for_targets(desc, targets):
    blueprint = Blueprint()
    for target in targets:
        create_modules_from_target(blueprint, desc, target)
    return blueprint


def main():
    parser = argparse.ArgumentParser(
          description='Generate Android.bp from a GN description.')
    parser.add_argument('desc',
          help='GN description (e.g., gn desc out --format=json --all-toolchains "//*"')
    args = parser.parse_args()

    with open(args.desc) as f:
        desc = json.load(f)

    targets = ["//:perfetto_tests"]
    blueprint = create_blueprint_for_targets(desc, targets)

    output = [
        '// Copyright (C) 2017 The Android Open Source Project',
        '//',
        '// Licensed under the Apache License, Version 2.0 (the "License");',
        '// you may not use this file except in compliance with the License.',
        '// You may obtain a copy of the License at',
        '//',
        '//      http://www.apache.org/licenses/LICENSE-2.0',
        '//',
        '// Unless required by applicable law or agreed to in writing, software',
        '// distributed under the License is distributed on an "AS IS" BASIS,',
        '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.',
        '// See the License for the specific language governing permissions and',
        '// limitations under the License.',
        '//',
        '// This file is automatically generated. Do not edit.',
        '']
    blueprint.to_string(output)
    print '\n'.join(output)


if __name__ == '__main__':
    sys.exit(main())
