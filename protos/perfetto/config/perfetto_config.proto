// AUTOGENERATED - DO NOT EDIT
// ---------------------------
// This file has been generated by
// AOSP://external/perfetto/tools/gen_merged_protos
// merging the perfetto config protos.
// This fused proto is intended to be copied in:
//  - Android tree, for statsd.
//  - Google internal repos.

syntax = "proto2";

package perfetto.protos;

// Begin of protos/perfetto/common/sys_stats_counters.proto

// Counter definitions for Linux's /proc/meminfo.
enum MeminfoCounters {
  MEM_TOTAL = 1;
  MEM_FREE = 2;
  MEM_AVAILABLE = 3;
  BUFFERS = 4;
  CACHED = 5;
  SWAP_CACHED = 6;
  ACTIVE = 7;
  INACTIVE = 8;
  ACTIVE_ANON = 9;
  INACTIVE_ANON = 10;
  ACTIVE_FILE = 11;
  INACTIVE_FILE = 12;
  UNEVICTABLE = 13;
  MLOCKED = 14;
  SWAP_TOTAL = 15;
  SWAP_FREE = 16;
  DIRTY = 17;
  WRITEBACK = 18;
  ANON_PAGES = 19;
  MAPPED = 20;
  SHMEM = 21;
  SLAB = 22;
  SLAB_RECLAIMABLE = 23;
  SLAB_UNRECLAIMABLE = 24;
  KERNEL_STACK = 25;
  PAGE_TABLES = 26;
  COMMIT_LIMIT = 27;
  COMMITED_AS = 28;
  VMALLOC_TOTAL = 29;
  VMALLOC_USED = 30;
  VMALLOC_CHUNK = 31;
  CMA_TOTAL = 32;
  CMA_FREE = 33;
}

// Counter definitions for Linux's /proc/vmstat.
enum VmstatCounters {
  NR_FREE_PAGES = 1;
  NR_ALLOC_BATCH = 2;
  NR_INACTIVE_ANON = 3;
  NR_ACTIVE_ANON = 4;
  NR_INACTIVE_FILE = 5;
  NR_ACTIVE_FILE = 6;
  NR_UNEVICTABLE = 7;
  NR_MLOCK = 8;
  NR_ANON_PAGES = 9;
  NR_MAPPED = 10;
  NR_FILE_PAGES = 11;
  NR_DIRTY = 12;
  NR_WRITEBACK = 13;
  NR_SLAB_RECLAIMABLE = 14;
  NR_SLAB_UNRECLAIMABLE = 15;
  NR_PAGE_TABLE_PAGES = 16;
  NR_KERNEL_STACK = 17;
  NR_OVERHEAD = 18;
  NR_UNSTABLE = 19;
  NR_BOUNCE = 20;
  NR_VMSCAN_WRITE = 21;
  NR_VMSCAN_IMMEDIATE_RECLAIM = 22;
  NR_WRITEBACK_TEMP = 23;
  NR_ISOLATED_ANON = 24;
  NR_ISOLATED_FILE = 25;
  NR_SHMEM = 26;
  NR_DIRTIED = 27;
  NR_WRITTEN = 28;
  NR_PAGES_SCANNED = 29;
  WORKINGSET_REFAULT = 30;
  WORKINGSET_ACTIVATE = 31;
  WORKINGSET_NODERECLAIM = 32;
  NR_ANON_TRANSPARENT_HUGEPAGES = 33;
  NR_FREE_CMA = 34;
  NR_SWAPCACHE = 35;
  NR_DIRTY_THRESHOLD = 36;
  NR_DIRTY_BACKGROUND_THRESHOLD = 37;
  PGPGIN = 38;
  PGPGOUT = 39;
  PGPGOUTCLEAN = 40;
  PSWPIN = 41;
  PSWPOUT = 42;
  PGALLOC_DMA = 43;
  PGALLOC_NORMAL = 44;
  PGALLOC_MOVABLE = 45;
  PGFREE = 46;
  PGACTIVATE = 47;
  PGDEACTIVATE = 48;
  PGFAULT = 49;
  PGMAJFAULT = 50;
  PGREFILL_DMA = 51;
  PGREFILL_NORMAL = 52;
  PGREFILL_MOVABLE = 53;
  PGSTEAL_KSWAPD_DMA = 54;
  PGSTEAL_KSWAPD_NORMAL = 55;
  PGSTEAL_KSWAPD_MOVABLE = 56;
  PGSTEAL_DIRECT_DMA = 57;
  PGSTEAL_DIRECT_NORMAL = 58;
  PGSTEAL_DIRECT_MOVABLE = 59;
  PGSCAN_KSWAPD_DMA = 60;
  PGSCAN_KSWAPD_NORMAL = 61;
  PGSCAN_KSWAPD_MOVABLE = 62;
  PGSCAN_DIRECT_DMA = 63;
  PGSCAN_DIRECT_NORMAL = 64;
  PGSCAN_DIRECT_MOVABLE = 65;
  PGSCAN_DIRECT_THROTTLE = 66;
  PGINODESTEAL = 67;
  SLABS_SCANNED = 68;
  KSWAPD_INODESTEAL = 69;
  KSWAPD_LOW_WMARK_HIT_QUICKLY = 70;
  KSWAPD_HIGH_WMARK_HIT_QUICKLY = 71;
  PAGEOUTRUN = 72;
  ALLOCSTALL = 73;
  PGROTATED = 74;
  DROP_PAGECACHE = 75;
  DROP_SLAB = 76;
  PGMIGRATE_SUCCESS = 77;
  PGMIGRATE_FAIL = 78;
  COMPACT_MIGRATE_SCANNED = 79;
  COMPACT_FREE_SCANNED = 80;
  COMPACT_ISOLATED = 81;
  COMPACT_STALL = 82;
  COMPACT_FAIL = 83;
  COMPACT_SUCCESS = 84;
  COMPACT_DAEMON_WAKE = 85;
  UNEVICTABLE_PGS_CULLED = 86;
  UNEVICTABLE_PGS_SCANNED = 87;
  UNEVICTABLE_PGS_RESCUED = 88;
  UNEVICTABLE_PGS_MLOCKED = 89;
  UNEVICTABLE_PGS_MUNLOCKED = 90;
  UNEVICTABLE_PGS_CLEARED = 91;
  UNEVICTABLE_PGS_STRANDED = 92;
}
// End of protos/perfetto/common/sys_stats_counters.proto

// Begin of protos/perfetto/config/chrome/chrome_config.proto

// When editing this file run ./tools/gen_tracing_cpp_headers_from_protos.py
// to reflect changes in the corresponding C++ headers.

message ChromeConfig {
  optional string trace_config = 1;
}

// End of protos/perfetto/config/chrome/chrome_config.proto

// Begin of protos/perfetto/config/data_source_config.proto


// When editing this file run ./tools/gen_tracing_cpp_headers_from_protos.py
// to reflect changes in the corresponding C++ headers.

// The configuration that is passed to each data source when starting tracing.
message DataSourceConfig {
  // Data source unique name, e.g., "linux.ftrace". This must match
  // the name passed by the data source when it registers (see
  // RegisterDataSource()).
  optional string name = 1;

  // The index of the logging buffer where TracePacket(s) will be stored.
  // This field doesn't make a major difference for the Producer(s). The final
  // logging buffers, in fact, are completely owned by the Service. We just ask
  // the Producer to copy this number into the chunk headers it emits, so that
  // the Service can quickly identify the buffer where to move the chunks into
  // without expensive lookups on its fastpath.
  optional uint32 target_buffer = 2;

  // Set by the service to indicate the duration of the trace.
  // DO NOT SET in consumer as this will be overridden by the service.
  optional uint32 trace_duration_ms = 3;

  // Set by the service to indicate which tracing session the data source
  // belongs to. The intended use case for this is checking if two data sources,
  // one of which produces metadata for the other one, belong to the same trace
  // session and hence should be linked together.
  // This field was introduced in Aug 2018 after Android P.
  optional uint64 tracing_session_id = 4;

  // Keeep the lower IDs (up to 99) for fields that are *not* specific to
  // data-sources and needs to be processed by the traced daemon.

  optional FtraceConfig ftrace_config = 100;
  optional ChromeConfig chrome_config = 101;
  optional InodeFileConfig inode_file_config = 102;
  optional ProcessStatsConfig process_stats_config = 103;
  optional SysStatsConfig sys_stats_config = 104;

  // This is a fallback mechanism to send a free-form text config to the
  // producer. In theory this should never be needed. All the code that
  // is part of the platform (i.e. traced service) is supposed to *not* truncate
  // the trace config proto and propagate unknown fields. However, if anything
  // in the pipeline (client or backend) ends up breaking this forward compat
  // plan, this field will become the escape hatch to allow future data sources
  // to get some meaningful configuration.
  optional string legacy_config = 1000;

  // This field is only used for testing.
  optional TestConfig for_testing =
      536870911;  // 2^29 - 1, max field id for protos.
}

// End of protos/perfetto/config/data_source_config.proto

// Begin of protos/perfetto/config/ftrace/ftrace_config.proto

// When editing this file run ./tools/gen_tracing_cpp_headers_from_protos.py
// to reflect changes in the corresponding C++ headers.

message FtraceConfig {
  repeated string ftrace_events = 1;
  repeated string atrace_categories = 2;
  repeated string atrace_apps = 3;
  // *Per-CPU* buffer size.
  optional uint32 buffer_size_kb = 10;
  optional uint32 drain_period_ms = 11;
}

// End of protos/perfetto/config/ftrace/ftrace_config.proto

// Begin of protos/perfetto/config/inode_file/inode_file_config.proto

// When editing this file run ./tools/gen_tracing_cpp_headers_from_protos.py
// to reflect changes in the corresponding C++ headers.

message InodeFileConfig {
  message MountPointMappingEntry {
    optional string mountpoint = 1;
    repeated string scan_roots = 2;
  }

  // How long to pause between batches.
  optional uint32 scan_interval_ms = 1;

  // How long to wait before the first scan in order to accumulate inodes.
  optional uint32 scan_delay_ms = 2;

  // How many inodes to scan in one batch.
  optional uint32 scan_batch_size = 3;

  // Do not scan for inodes not found in the static map.
  optional bool do_not_scan = 4;

  // If non-empty, only scan inodes corresponding to block devices named in
  // this list.
  repeated string scan_mount_points = 5;

  // When encountering an inode belonging to a block device corresponding
  // to one of the mount points in this map, scan its scan_roots instead.
  repeated MountPointMappingEntry mount_point_mapping = 6;
}

// End of protos/perfetto/config/inode_file/inode_file_config.proto

// Begin of protos/perfetto/config/process_stats/process_stats_config.proto

// When editing this file run ./tools/gen_tracing_cpp_headers_from_protos.py
// to reflect changes in the corresponding C++ headers.

message ProcessStatsConfig {
  enum Quirks {
    QUIRKS_UNSPECIFIED = 0;

    // This has been deprecated and ignored as per 2018-05-01. Full scan at
    // startup is now disabled by default and can be re-enabled using the
    // |scan_all_processes_on_start| arg.
    DISABLE_INITIAL_DUMP = 1 [deprecated = true];

    DISABLE_ON_DEMAND = 2;
  }

  repeated Quirks quirks = 1;

  // If enabled all processes will be scanned and dumped when the trace starts.
  optional bool scan_all_processes_on_start = 2;

  // If enabled thread names are also recoded (this is redundant if sched_switch
  // is enabled).
  optional bool record_thread_names = 3;
}

// End of protos/perfetto/config/process_stats/process_stats_config.proto

// Begin of protos/perfetto/config/sys_stats/sys_stats_config.proto


// When editing this file run ./tools/gen_tracing_cpp_headers_from_protos.py
// to reflect changes in the corresponding C++ headers.

// Periods for meminfo/vmstat/stat need to be integer multiples of each other.
// OK:     [10ms, 10ms, 10ms],  [10ms, 20ms, 10ms],  [10ms, 20ms, 50ms]
// Not OK: [10ms, 10ms, 11ms],  [10ms, 15ms, 20ms]
message SysStatsConfig {
  // Polls /proc/meminfo every X ms, if non-zero.
  optional uint32 meminfo_period_ms = 1;

  // If not-empty reports only the given counters.
  // If empty all known counters are reported.
  repeated MeminfoCounters meminfo_counters = 2;

  // Polls /proc/vmstat every X ms, if non-zero.
  optional uint32 vmstat_period_ms = 3;
  repeated VmstatCounters vmstat_counters = 4;

  // Pols /proc/stat every X ms, if non-zero.
  optional uint32 stat_period_ms = 5;
  enum StatCounters {
    CPU_TIMES = 1;
    IRQ_COUNTS = 2;
    SOFTIRQ_COUNTS = 3;
    FORK_COUNT = 4;
  }
  repeated StatCounters stat_counters = 6;
}

// End of protos/perfetto/config/sys_stats/sys_stats_config.proto

// Begin of protos/perfetto/config/test_config.proto

// When editing this file run ./tools/gen_tracing_cpp_headers_from_protos.py
// to reflect changes in the corresponding C++ headers.

// The configuration for a fake producer used in tests.
message TestConfig {
  // The number of messages the fake producer should send.
  optional uint32 message_count = 1;

  // The maximum number of messages which should be sent each second.
  // The actual obserced speed may be lower if the producer is unable to
  // work fast enough.
  // If this is zero or unset, the producer will send as fast as possible.
  optional uint32 max_messages_per_second = 2;

  // The seed value for a simple multiplicative congruential pseudo-random
  // number sequence.
  optional uint32 seed = 3;

  // The size of each message in bytes. Should be greater than or equal 5 to
  // account for the number of bytes needed to encode the random number and a
  // null byte for the string.
  optional uint32 message_size = 4;

  // Whether the producer should send a event batch when the data source is
  // is initially registered.
  optional bool send_batch_on_register = 5;
}

// End of protos/perfetto/config/test_config.proto

// Begin of protos/perfetto/config/trace_config.proto

// When editing this file run ./tools/gen_tracing_cpp_headers_from_protos.py
// to reflect changes in the corresponding C++ headers.

// The overall config that is used when starting a new tracing session through
// ProducerPort::StartTracing().
// It contains the general config for the logging buffer(s) and the configs for
// all the data source being enabled.
//
// Next id: 12.
message TraceConfig {
  message BufferConfig {
    optional uint32 size_kb = 1;

    reserved 2;  // |page_size|, now deprecated.
    reserved 3;  // |optimize_for|, now deprecated.

    enum FillPolicy {
      UNSPECIFIED = 0;
      RING_BUFFER = 1;
      // TODO: not implemented yet.
      // STOP_WHEN_FULL = 2;
    }
    optional FillPolicy fill_policy = 4;
  }
  repeated BufferConfig buffers = 1;

  message DataSource {
    // Filters and data-source specific config. It contains also the unique name
    // of the data source, the one passed in the  DataSourceDescriptor when they
    // register on the service.
    optional protos.DataSourceConfig config = 1;

    // Optional. If multiple producers (~processes) expose the same data source
    // and |producer_name_filter| != "", the data source is enabled only for
    // producers whose names match any of the producer_name_filter below.
    // The |producer_name_filter| has to be an exact match. (TODO:
    // support wildcards or regex).
    // This allows to enable a data source only for specific processes.
    // The "repeated" field has OR sematics: specifying a filter ["foo", "bar"]
    // will enable data source on both "foo" and "bar" (if existent).
    repeated string producer_name_filter = 2;
  }
  repeated DataSource data_sources = 2;

  optional uint32 duration_ms = 3;

  // This is set when --dropbox is passed to the Perfetto command line client
  // and enables guardrails that limit resource usage for traces requested
  // by statsd.
  optional bool enable_extra_guardrails = 4;

  enum LockdownModeOperation {
    LOCKDOWN_UNCHANGED = 0;
    LOCKDOWN_CLEAR = 1;
    LOCKDOWN_SET = 2;
  }
  // Reject producers that are not running under the same UID as the tracing
  // service.
  optional LockdownModeOperation lockdown_mode = 5;

  message ProducerConfig {
    // Identifies the producer for which this config is for.
    optional string producer_name = 1;

    // Specifies the preferred size of the shared memory buffer. If the size is
    // larger than the max size, the max will be used. If it is smaller than
    // the page size or doesn't fit pages evenly into it, it will fall back to
    // the size specified by the producer or finally the default shared memory
    // size.
    optional uint32 shm_size_kb = 2;

    // Specifies the preferred size of each page in the shared memory buffer.
    // Must be an integer multiple of 4K.
    optional uint32 page_size_kb = 3;
  }

  repeated ProducerConfig producers = 6;

  // Contains statsd-specific metadata about an alert associated with the trace.
  message StatsdMetadata {
    // The identifier of the alert which triggered this trace.
    optional int64 triggering_alert_id = 1;
    // The uid which registered the triggering configuration with statsd.
    optional int32 triggering_config_uid = 2;
    // The identifier of the config which triggered the alert.
    optional int64 triggering_config_id = 3;
  }

  // Statsd-specific metadata.
  optional StatsdMetadata statsd_metadata = 7;

  // When true, the EnableTracing() request must also provide a file descriptor.
  // The service will then periodically read packets out of the trace buffer and
  // store it into the passed file.
  optional bool write_into_file = 8;

  // Optional. If non-zero tunes the write period. A min value of 100ms is
  // enforced (i.e. smaller values are ignored).
  optional uint32 file_write_period_ms = 9;

  // Optional. When non zero the periodic write stops once at most X bytes
  // have been written into the file. Tracing is disabled when this limit is
  // reached, even if |duration_ms| has not been reached yet.
  optional uint64 max_file_size_bytes = 10;

  // Contains flags which override the default values of the guardrails inside
  // Perfetto. These values are only affect userdebug builds.
  message GuardrailOverrides {
    // Override the default limit (in bytes) for uploading data to server within
    // a 24 hour period.
    optional uint64 max_upload_per_day_bytes = 1;
  }

  optional GuardrailOverrides guardrail_overrides = 11;
}

// End of protos/perfetto/config/trace_config.proto
