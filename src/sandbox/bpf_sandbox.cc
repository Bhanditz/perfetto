/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "src/sandbox/bpf_sandbox.h"

#include <linux/audit.h>
#include <linux/seccomp.h>
#include <sys/prctl.h>
#include <sys/syscall.h>

#include <limits>

#include "perfetto/base/logging.h"
#include "perfetto/base/utils.h"

namespace perfetto {

namespace {

// Note: The offsets in the statements are relative to the seccomp_data struct
// that looks like this:
// struct seccomp_data {
//     int      nr;                   // System call number.
//     uint32_t arch;                 // AUDIT_ARCH_* value.
//     uint64_t instruction_pointer;  // CPU instruction pointer.
//     uint64_t args[6];              // Syscall arguments (up to 6).
//  };

#pragma GCC diagnostic ignored "-Wextended-offsetof"
#define SECCOMP_LOAD_FIELD(x)        \
  BPF_STMT(BPF_LD + BPF_W + BPF_ABS, \
           static_cast<uint32_t>(offsetof(struct seccomp_data, x)))
#define SECCOMP_LOAD_SYSCALL_NR() SECCOMP_LOAD_FIELD(nr)
#define SECCOMP_LOAD_SYSCALL_ARCH() SECCOMP_LOAD_FIELD(arch)
#define SECCOMP_LOAD_SYSCALL_ARG(n) SECCOMP_LOAD_FIELD(args[n])

#if defined(__i386__)
#define SECCOMP_ARCH AUDIT_ARCH_I386
#elif defined(__x86_64__)
#define SECCOMP_ARCH AUDIT_ARCH_X86_64
#elif defined(__mips32__)
#define SECCOMP_ARCH AUDIT_ARCH_MIPSEL
#elif defined(__mips64__)
#define SECCOMP_ARCH AUDIT_ARCH_MIPSEL64
#elif defined(__arm__) && (defined(__thumb__) || defined(__ARM_EABI__))
#define SECCOMP_ARCH AUDIT_ARCH_ARM
#elif defined(__aarch64__)
#define SECCOMP_ARCH AUDIT_ARCH_AARCH64
#endif

}  // namespace

BPFSandbox::BPFSandbox(uint32_t fail_action) : fail_action_(fail_action) {
  prog_.reserve(200);  // Some realistic value to reduce reallocations.

  // Only accept syscalls for the current architecture.
  prog_.push_back(SECCOMP_LOAD_SYSCALL_ARCH());
  prog_.push_back(BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, SECCOMP_ARCH, 1, 0));
  prog_.push_back(BPF_STMT(BPF_RET + BPF_K, fail_action_));
}

void BPFSandbox::AllowSyscall(unsigned int nr) {
  prog_.push_back(BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, nr, 0, 1));
  prog_.push_back(BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW));
}

// The statements generated by a syscall + arg matcher look like this:
// (Assume that the previous rules loaded the syscall nr into the W register).
// #0 Check the syscall number, if doesn't match jump to #8 (next + 7)
//   BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, nr, 0, 7)
// #1 Load syscall arg 0
//   SECCOMP_LOAD_SYSCALL_ARG(0)
// #2 Check predicate: if matches jump to next, if fails jump to #8 (next + 5)
//   BPF_JUMP(BPF_JMP + BPF_K + predicate0, value0, 0, 5)
// #3 Load syscall arg 1
//   SECCOMP_LOAD_SYSCALL_ARG(1)
// #4 Check *negative* predicate: if matches jump to #8 (next + 3), if doesn't
// match (good, given the negation), jump to next.
//   BPF_JUMP(BPF_JMP + BPF_K + predicate1, value1, 3, 0)
// #5 Load syscall arg 2
//   SECCOMP_LOAD_SYSCALL_ARG(2)
// #6 Check predicate: if matches jump to next, if fails jump to #8 (next + 1)
//   BPF_JUMP(BPF_JMP + BPF_K + predicate2, value2, 0, 1)
// #7 All predicates match, allow the syscall.
//   BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW)
// #8 Either the initial syscall check or an arg predicate failed. Reload the
// syscall number in the W register and continue with the next rule.
//   SECCOMP_LOAD_SYSCALL_NR()
void BPFSandbox::AllowSyscall(unsigned int nr,
                              std::initializer_list<ArgMatcher> args) {
  PERFETTO_CHECK(!finalized_);
  struct seccomp_data x;
  PERFETTO_CHECK(args.size() <= base::ArraySize(x.args));
  // size() * 2 + 1 jumps to the final SECCOMP_LOAD_SYSCALL_NR() statement
  // which reloads the syscall number in the W register and moved to the next
  // filter (or the last failure statement, if any).
  const uint8_t jmp_end = static_cast<uint8_t>(args.size() * 2 + 1);
  prog_.push_back(BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, nr, 0, jmp_end));
  size_t i = 0;
  for (const ArgMatcher& m : args) {
    const uint8_t end = static_cast<uint8_t>(2 * (args.size() - i) - 1);
    prog_.push_back(SECCOMP_LOAD_SYSCALL_ARG(i));
    if (m.flags & ArgMatcher::kNot) {
      prog_.push_back(BPF_JUMP(BPF_JMP + BPF_K + m.pred, m.value, end, 0));

    } else {
      prog_.push_back(BPF_JUMP(BPF_JMP + BPF_K + m.pred, m.value, 0, end));
    }
    i++;
  }

  prog_.push_back(BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW));
  prog_.push_back(SECCOMP_LOAD_SYSCALL_NR());
}

void BPFSandbox::EnterSandbox() {
  if (finalized_)
    return;
  finalized_ = true;
  prog_.push_back(BPF_STMT(BPF_RET + BPF_K, fail_action_));

  struct sock_fprog filterprog = {};
  PERFETTO_CHECK(prog_.size() <
                 std::numeric_limits<decltype(filterprog.len)>::max());
  filterprog.len = static_cast<decltype(filterprog.len)>(prog_.size());
  filterprog.filter = prog_.data();

  // Enter sandbox.
  PERFETTO_CHECK(prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) == 0);
  PERFETTO_CHECK(prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &filterprog) == 0);
  PERFETTO_DLOG("Entered BPF sandbox");
}

void InitServiceSandboxOrDie() {
  BPFSandbox bpf(SECCOMP_RET_TRAP);
  bpf.AllowSyscall(SYS_ppoll);  // For task runners.
  bpf.AllowSyscall(SYS_read);
  bpf.AllowSyscall(SYS_madvise);
  bpf.AllowSyscall(SYS_write);
  bpf.AllowSyscall(SYS_mmap);
  bpf.AllowSyscall(SYS_munmap);
  bpf.AllowSyscall(SYS_mprotect);
  bpf.AllowSyscall(SYS_futex);         // For liunwind.
  bpf.AllowSyscall(SYS_rt_sigaction);  // Only debug.
  bpf.AllowSyscall(SYS_exit_group);
  bpf.EnterSandbox();
}

}  // namespace perfetto
