/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "src/sandbox/bpf_sandbox.h"

#include <linux/audit.h>
#include <sys/prctl.h>
#include <sys/syscall.h>

#include <limits>

#include "perfetto/base/utils.h"

namespace perfetto {

namespace {

// Note: The offsets in the statements are relative to the seccomp_data struct
// that looks like this:
// struct seccomp_data {
//     int      nr;                   // System call number.
//     uint32_t arch;                 // AUDIT_ARCH_* value.
//     uint64_t instruction_pointer;  // CPU instruction pointer.
//     uint64_t args[6];              // Syscall arguments (up to 6).
//  };

#define SECCOMP_LOAD(x) \
  BPF_STMT(BPF_LD + BPF_W + BPF_ABS, static_cast<uint32_t>(x))

#define SECCOMP_LOAD_SYSCALL_NR() \
  SECCOMP_LOAD(offsetof(struct seccomp_data, nr))

#define SECCOMP_LOAD_SYSCALL_ARCH() \
  SECCOMP_LOAD(offsetof(struct seccomp_data, arch))

#define SECCOMP_LOAD_SYSCALL_ARG(n)                  \
  SECCOMP_LOAD(offsetof(struct seccomp_data, args) + \
               n * sizeof(reinterpret_cast<struct seccomp_data*>(0)->args[0]))

#if defined(__i386__)
#define SECCOMP_ARCH AUDIT_ARCH_I386
#elif defined(__x86_64__)
#define SECCOMP_ARCH AUDIT_ARCH_X86_64
#elif defined(__mips32__)
#define SECCOMP_ARCH AUDIT_ARCH_MIPSEL
#elif defined(__mips64__)
#define SECCOMP_ARCH AUDIT_ARCH_MIPSEL64
#elif defined(__arm__) && (defined(__thumb__) || defined(__ARM_EABI__))
#define SECCOMP_ARCH AUDIT_ARCH_ARM
#elif defined(__aarch64__)
#define SECCOMP_ARCH AUDIT_ARCH_AARCH64
#endif

constexpr auto kFailAction = SECCOMP_RET_TRAP;
}  // namespace

BpfSandbox::BpfSandbox() {
  // Only accept syscalls for the current architecture.
  append(SECCOMP_LOAD_SYSCALL_ARCH());
  append(BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, SECCOMP_ARCH, 1, 0));
  append(BPF_STMT(BPF_RET + BPF_K, kFailAction));
  append(SECCOMP_LOAD_SYSCALL_NR());

// Allow syscalls required by debug_crash_stack_trace.cc for unwinding.
#if !defined(NDEBUG)
  Allow(SYS_futex);
  Allow(SYS_rt_sigaction);
  Allow(SYS_sigaltstack);
#endif
}

void BpfSandbox::Allow(unsigned int nr) {
  append(BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, nr, 0, 1));
  append(BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW));
}

// The statements generated by a syscall + arg matcher look like this:
// (Assume that the previous rules loaded the syscall nr into the W register).
// #0 Check the syscall number, if doesn't match jump to #8 (next + 7)
//   BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, nr, 0, 7)
// #1 Load syscall arg 0
//   SECCOMP_LOAD_SYSCALL_ARG(0)
// #2 Check predicate: if matches jump to next, if fails jump to #8 (next + 5)
//   BPF_JUMP(BPF_JMP + BPF_K + predicate0, value0, 0, 5)
// #3 Load syscall arg 1
//   SECCOMP_LOAD_SYSCALL_ARG(1)
// #4 Check *negative* predicate: if matches jump to #8 (next + 3), if doesn't
// match (good, given the negation), jump to next.
//   BPF_JUMP(BPF_JMP + BPF_K + predicate1, value1, 3, 0)
// #5 Load syscall arg 2
//   SECCOMP_LOAD_SYSCALL_ARG(2)
// #6 Check predicate: if matches jump to next, if fails jump to #8 (next + 1)
//   BPF_JUMP(BPF_JMP + BPF_K + predicate2, value2, 0, 1)
// #7 All predicates match, allow the syscall.
//   BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW)
// #8 Either the initial syscall check or an arg predicate failed. Reload the
// syscall number in the W register and continue with the next rule.
//   SECCOMP_LOAD_SYSCALL_NR()
void BpfSandbox::Allow(unsigned int nr,
                       std::initializer_list<ArgMatcher> args) {
  static_assert(BPF_JA == 0, "The empty matcher {} assumes JumpAlways == 0");
  PERFETTO_CHECK(!finalized_);
  struct seccomp_data x;
  PERFETTO_CHECK(args.size() <= base::ArraySize(x.args));
  // size() * 2 + 1 jumps to the final SECCOMP_LOAD_SYSCALL_NR() statement
  // which reloads the syscall number in the W register and moved to the next
  // filter (or the last failure statement, if any).
  const uint8_t jmp_end = static_cast<uint8_t>(args.size() * 2 + 1);
  append(BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, nr, 0, jmp_end));
  size_t i = 0;
  for (const ArgMatcher& m : args) {
    const uint8_t end = static_cast<uint8_t>(2 * (args.size() - i) - 1);
    append(SECCOMP_LOAD_SYSCALL_ARG(i));
    if (m.flags & kNot) {
      append(BPF_JUMP(BPF_JMP + BPF_K + m.pred, m.value, end, 0));

    } else {
      append(BPF_JUMP(BPF_JMP + BPF_K + m.pred, m.value, 0, end));
    }
    i++;
  }

  append(BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW));
  append(SECCOMP_LOAD_SYSCALL_NR());
}

void BpfSandbox::EnterSandboxOrDie() {
  if (finalized_)
    return;
  finalized_ = true;

  // TODO(primiano): check that no threads exists at this point.

  append(BPF_STMT(BPF_RET + BPF_K, kFailAction));

  struct sock_fprog filterprog = {};
  static_assert(
      kProgSize < std::numeric_limits<decltype(filterprog.len)>::max(),
      "kProgSize too big");
  filterprog.len = static_cast<decltype(filterprog.len)>(prog_size_);
  filterprog.filter = prog_;

  // Do not remove this logging line. On Android this warms up the initializers
  // of liblog that would otherwise require extra open()-like syscalls.
  PERFETTO_LOG("Entering BPF sandbox");

  // Enter sandbox.
  PERFETTO_CHECK(prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) == 0);
  PERFETTO_CHECK(prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &filterprog) == 0);
}

}  // namespace perfetto
