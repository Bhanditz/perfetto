/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "src/sandbox/bpf_sandbox.h"

#include <linux/audit.h>
#include <sys/prctl.h>
#include <sys/syscall.h>

#include <limits>

#include "perfetto/base/utils.h"

namespace perfetto {

namespace {

// Note: The offsets in the statements are relative to the seccomp_data struct
// that looks like this:
// struct seccomp_data {
//     int      nr;                   // System call number.
//     uint32_t arch;                 // AUDIT_ARCH_* value.
//     uint64_t instruction_pointer;  // CPU instruction pointer.
//     uint64_t args[6];              // Syscall arguments (up to 6).
//  };

#define SECCOMP_LOAD(x) \
  BPF_STMT(BPF_LD + BPF_W + BPF_ABS, static_cast<uint32_t>(x))

#define SECCOMP_LOAD_SYSCALL_NR() \
  SECCOMP_LOAD(offsetof(struct seccomp_data, nr))

#define SECCOMP_LOAD_SYSCALL_ARCH() \
  SECCOMP_LOAD(offsetof(struct seccomp_data, arch))

#define SECCOMP_LOAD_SYSCALL_ARG(n)                  \
  SECCOMP_LOAD(offsetof(struct seccomp_data, args) + \
               n * sizeof(reinterpret_cast<struct seccomp_data*>(0)->args[0]))

#if defined(__i386__)
#define SECCOMP_ARCH AUDIT_ARCH_I386
#elif defined(__x86_64__)
#define SECCOMP_ARCH AUDIT_ARCH_X86_64
#elif defined(__mips32__)
#define SECCOMP_ARCH AUDIT_ARCH_MIPSEL
#elif defined(__mips64__)
#define SECCOMP_ARCH AUDIT_ARCH_MIPSEL64
#elif defined(__arm__) && (defined(__thumb__) || defined(__ARM_EABI__))
#define SECCOMP_ARCH AUDIT_ARCH_ARM
#elif defined(__aarch64__)
#define SECCOMP_ARCH AUDIT_ARCH_AARCH64
#endif

constexpr auto kFailAction = SECCOMP_RET_TRAP;
}  // namespace

BpfSandbox::BpfSandbox() {
  // Only accept syscalls for the current architecture.
  Append(SECCOMP_LOAD_SYSCALL_ARCH());
  Append(BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, SECCOMP_ARCH, 1, 0));
  Append(BPF_STMT(BPF_RET + BPF_K, kFailAction));
  Append(SECCOMP_LOAD_SYSCALL_NR());

// Allow syscalls required by debug_crash_stack_trace.cc for unwinding.
#if !defined(NDEBUG)
  Allow({
      {SYS_futex, {}}, {SYS_rt_sigaction, {}}, {SYS_sigaltstack, {}},
  });
#endif
}

void BpfSandbox::Allow(const SyscallFilter filters[], size_t filters_size) {
  for (size_t i = 0; i < filters_size; i++)
    AllowOne(filters[i]);
}

void BpfSandbox::AllowOne(const SyscallFilter& filter) {
  PERFETTO_CHECK(!finalized_);

  // Avoid emitting per-arg predicates for the case of a simple filter based
  //  only on the syscall number.
  if (filter.num_args() == 0) {
    Append(BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, filter.nr, 0, 1));
    Append(BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW));
    return;
  }

  // More general case of a filter involving both syscall number and args.
  // The statements generated by a syscall + arg matcher look like this:
  // (Assume that the previous rules loaded the syscall nr into the W register).
  // #0 Check the syscall number, if doesn't match jump to #8 (next + 7)
  //   BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, nr, 0, 7)
  // #1 Load syscall arg 0
  //   SECCOMP_LOAD_SYSCALL_ARG(0)
  // #2 Check predicate: if matches jump to next, if fails jump to #8 (next + 5)
  //   BPF_JUMP(BPF_JMP + BPF_K + predicate0, value0, 0, 5)
  // #3 Load syscall arg 1
  //   SECCOMP_LOAD_SYSCALL_ARG(1)
  // #4 Check *negative* predicate: if matches jump to #8 (next + 3), if doesn't
  // match (good, given the negation), jump to next.
  //   BPF_JUMP(BPF_JMP + BPF_K + predicate1, value1, 3, 0)
  // #5 Load syscall arg 2
  //   SECCOMP_LOAD_SYSCALL_ARG(2)
  // #6 Check predicate: if matches jump to next, if fails jump to #8 (next + 1)
  //   BPF_JUMP(BPF_JMP + BPF_K + predicate2, value2, 0, 1)
  // #7 All predicates match, allow the syscall.
  //   BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW)
  // #8 Either the initial syscall check or an arg predicate failed. Reload the
  // syscall number in the W register and continue with the next rule.
  //   SECCOMP_LOAD_SYSCALL_NR()

  static_assert(BPF_JA == 0, "The empty matcher {} assumes JumpAlways == 0");
  struct seccomp_data x;
  const auto& args = filter.args;
  PERFETTO_CHECK(base::ArraySize(args) <= base::ArraySize(x.args));

  // size() * 2 + 1 jumps to the final SECCOMP_LOAD_SYSCALL_NR() statement
  // which reloads the syscall number in the W register and moved to the next
  // filter (or the last failure statement, if any).
  const uint8_t jmp_end = static_cast<uint8_t>(filter.num_args() * 2 + 1);
  Append(BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, filter.nr, 0, jmp_end));
  for (size_t i = 0; i < filter.num_args(); i++) {
    const ArgFilter& arg = filter.args[i];
    const uint8_t end = static_cast<uint8_t>(2 * (filter.num_args() - i) - 1);
    Append(SECCOMP_LOAD_SYSCALL_ARG(i));
    if (arg.flags & kNot) {
      Append(BPF_JUMP(BPF_JMP + BPF_K + arg.op, arg.value, end, 0));
    } else {
      Append(BPF_JUMP(BPF_JMP + BPF_K + arg.op, arg.value, 0, end));
    }
  }

  Append(BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW));
  Append(SECCOMP_LOAD_SYSCALL_NR());
}

void BpfSandbox::EnterSandboxOrDie() {
  if (finalized_)
    return;
  finalized_ = true;

  // TODO(primiano): check that no threads exists at this point.

  Append(BPF_STMT(BPF_RET + BPF_K, kFailAction));

  struct sock_fprog filterprog = {};
  static_assert(
      kProgSize < std::numeric_limits<decltype(filterprog.len)>::max(),
      "kProgSize too big");
  filterprog.len = static_cast<decltype(filterprog.len)>(prog_size_);
  filterprog.filter = prog_;

  // Do not remove this logging line. On Android this warms up the initializers
  // of liblog that would otherwise require extra open()-like syscalls.
  PERFETTO_LOG("Entering BPF sandbox");

  // Enter sandbox.
  PERFETTO_CHECK(prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) == 0);
  PERFETTO_CHECK(prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &filterprog) == 0);
}

size_t BpfSandbox::SyscallFilter::num_args() const {
  static_assert(sizeof(args) == kMaxArgs * sizeof(ArgFilter),
                "#args != kMaxArgs");
  for (size_t n = kMaxArgs; n > 0; n--) {
    if (!args[n - 1].empty())
      return n;
  }
  return 0;
}

}  // namespace perfetto
