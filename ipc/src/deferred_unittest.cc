/*
 * Copyright (C) 2017 The Android Open foo Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "ipc/deferred.h"

#include "gtest/gtest.h"

#include "deferred_unittest_messages.pb.h"  // Autogenerated from protobuf.

namespace perfetto {
namespace ipc {
namespace {

TEST(DeferredTest, BindAndResolve) {
  Deferred<TestMessageFoo> deferred(
      std::unique_ptr<ProtoMessage>(new TestMessageFoo()));
  int num_callbacks = 0;
  deferred.Bind([&num_callbacks](Deferred<TestMessageFoo> msg) {
    ASSERT_TRUE(msg.success());
    ASSERT_EQ(42, msg->num());
    ASSERT_EQ("foo", msg->str());
    num_callbacks++;
  });

  deferred->set_num(42);
  (*deferred).set_str("foo");
  deferred.Resolve();

  // A second call to Resolve() or Fail() shouldn't have any effect beause we
  // didn't set has_more.
  deferred.Resolve();
  deferred.Fail();

  ASSERT_EQ(1, num_callbacks);
}

// In case of a Fail() a callback with a nullptr should be received.
TEST(DeferredTest, BindAndFail) {
  Deferred<TestMessageFoo> deferred(
      std::unique_ptr<ProtoMessage>(new TestMessageFoo()));
  int num_callbacks = 0;
  deferred.Bind([&num_callbacks](Deferred<TestMessageFoo> msg) {
    ASSERT_FALSE(msg.success());
    ASSERT_EQ(nullptr, msg.unchecked_msg());
    num_callbacks++;
  });

  deferred->set_num(42);
  (*deferred).set_str("foo");
  deferred.Fail();
  deferred.Resolve();  // This should have no effect.
  deferred.Fail();     // ditto.

  ASSERT_EQ(1, num_callbacks);
}

// In case of a Fail() a callback with a nullptr should be received.
TEST(DeferredTest, AutoFailIfOutOfScope) {
  int num_callbacks = 0;
  {
    Deferred<TestMessageFoo> deferred(
        std::unique_ptr<ProtoMessage>(new TestMessageFoo()));
    deferred.Bind([&num_callbacks](Deferred<TestMessageFoo> msg) {
      ASSERT_FALSE(msg.success());
      num_callbacks++;
    });
    deferred->set_num(42);
  }
  ASSERT_EQ(1, num_callbacks);
}

// Binds two callbacks one after the other, tests that the bind state of the
// first callback is released.
TEST(DeferredTest, BindTwice) {
  // shared_ptr has a very nice use_count() that we can leverage to check that
  // the bind state is not leaked.
  std::shared_ptr<int> shared_bind_state(new int{13});

  int num_callbacks = 0;
  Deferred<TestMessageFoo> deferred(
      std::unique_ptr<ProtoMessage>(new TestMessageFoo()));
  deferred.Bind([shared_bind_state](Deferred<TestMessageFoo>) {
    *shared_bind_state = 0;
  });
  // At this point both us (|shared_bind_state|) and the Deferred are
  // refcounting the bind state.
  ASSERT_GE(shared_bind_state.use_count(), 2);

  // Re-binding the callback should release the bind state, without invoking the
  // old callback.
  deferred.Bind([&num_callbacks](Deferred<TestMessageFoo> msg) {
    ASSERT_TRUE(msg.success());
    ASSERT_EQ(42, msg->num());
    num_callbacks++;
  });
  ASSERT_EQ(1, shared_bind_state.use_count());
  ASSERT_EQ(13, *shared_bind_state);

  // Test that the new callback is invoked.
  deferred->set_num(42);
  deferred.Resolve();
  ASSERT_EQ(1, num_callbacks);
}

// Converts a Deferred<Specialized> into a Deferred<ProtoMessage> and
// invokes the callback from the latter. The callback should work consistently.
TEST(DeferredTest, UpcastAndResolve) {
  std::shared_ptr<int> shared_bind_state(new int{13});

  Deferred<TestMessageFoo> deferred(
      std::unique_ptr<ProtoMessage>(new TestMessageFoo()));
  deferred->set_num(42);
  deferred->set_str("foo");
  int num_callbacks = 0;
  deferred.Bind(
      [shared_bind_state, &num_callbacks](Deferred<TestMessageFoo> msg) {
        ASSERT_TRUE(msg.success());
        ASSERT_EQ(42, msg->num());
        ASSERT_EQ("foo", msg->str());
        num_callbacks++;
      });
  const int refcount_after_first_bind = shared_bind_state.use_count();

  ASSERT_TRUE(deferred.is_bound());
  Deferred<ProtoMessage> generic_deferred =
      deferred.template CovnvertInternal<ProtoMessage>();
  ASSERT_FALSE(deferred.is_bound());
  ASSERT_TRUE(generic_deferred.is_bound());
  ASSERT_EQ(refcount_after_first_bind, shared_bind_state.use_count());
  ASSERT_EQ(0, num_callbacks);

  // Resolving the upcasted deferred should still trigger the callback.
  std::weak_ptr<int> weak_bind_state(shared_bind_state);
  shared_bind_state.reset();

  // The bind state should be retained by the callback in |generic_deferred|.
  ASSERT_GT(weak_bind_state.use_count(), 0);

  generic_deferred.Resolve();
  ASSERT_EQ(1, num_callbacks);

  // And at this point nothing else should be retaining the bind state, as
  // Resolve() with has_more = false releases it.
  ASSERT_EQ(0, weak_bind_state.use_count());
}

// Like UpcastAndResolve but goes back and forth between
// Deferred<Specialized> -> Deferred<ProtoMessage> -> Deferred<Specialized>.
TEST(DeferredTest, UpAndDowncast) {
  std::shared_ptr<int> shared_bind_state(new int{13});
  Deferred<TestMessageFoo> deferred(
      std::unique_ptr<ProtoMessage>(new TestMessageFoo()));
  deferred->set_num(42);
  deferred->set_str("foo");

  int num_callbacks = 0;
  deferred.Bind(
      [shared_bind_state, &num_callbacks](Deferred<TestMessageFoo> msg) {
        ASSERT_TRUE(msg.success());
        ASSERT_EQ(42, msg->num());
        ASSERT_EQ("foo", msg->str());
        num_callbacks++;
      });

  Deferred<ProtoMessage> generic_deferred =
      deferred.template CovnvertInternal<ProtoMessage>();
  // Deferred<TestMessageFoo> downcast
  // TODO WIP.
}

TEST(DeferredTest, MoveOperators) {
  int num_callbacks = 0;
  Deferred<TestMessageFoo> deferred(
      std::unique_ptr<ProtoMessage>(new TestMessageFoo()));
  auto callback = [&num_callbacks](Deferred<TestMessageFoo> msg) {
    ASSERT_TRUE(msg.success());
    ASSERT_GE(msg->num(), 42);
    ASSERT_LE(msg->num(), 43);
    ASSERT_EQ("foo_" + std::to_string(msg->num()), msg->str());
    num_callbacks++;
  };
  deferred->set_num(42);
  deferred.Bind(callback);

  // The result of the 3 statements below should be: moved_deferred <- deferred.
  Deferred<TestMessageFoo> moved_deferred(std::move(deferred));
  deferred = std::move(moved_deferred);
  moved_deferred = std::move(deferred);

  moved_deferred->set_str("foo_42");
  deferred
      .Resolve();  // Nothing should happen yet, |deferred| has been cleared.
  ASSERT_EQ(0, num_callbacks);

  moved_deferred.Resolve();
  ASSERT_EQ(1, num_callbacks);

  // |deferred| has lost all its state but shoould remain reusable.
  deferred.Bind(callback);
  deferred.set_msg(std::unique_ptr<ProtoMessage>(new TestMessageFoo()));
  deferred->set_num(43);
  deferred->set_str("foo_43");
  deferred.Resolve();
  ASSERT_EQ(2, num_callbacks);

  // Finally re-bind |deferred|, move it to a new scoped Deferred and verify
  // that the moved-into object still auto-nacks the callback.
  deferred.Bind([&num_callbacks](Deferred<TestMessageFoo> msg) {
    ASSERT_FALSE(msg.success());
    num_callbacks++;
  });
  { Deferred<TestMessageFoo> scoped_deferred(std::move(deferred)); }
  ASSERT_EQ(3, num_callbacks);
}

TEST(DeferredTest, HasMore) {}

}  // namespace
}  // namespace ipc
}  // namespace perfetto
